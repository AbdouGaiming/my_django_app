Project skeleton (Django-first)
Create one Django project (e.g., learningroadmap/) and split features into apps: accounts, profiles, roadmaps, resources, assessments, telemetry, ai_orchestrator.

Choose data stores early: Postgres for core data, Redis for caching + background job broker, and object storage (S3-compatible) for exported JSON files.

Define environments (local/staging/prod), secrets management, and basic observability (structured logs, error reporting, request IDs).

Data model + API (DRF inside Django)
Implement models:

LearnerProfile (subject, level, goals, preferences, weekly_hours, deadline, language, age_range)

ClarifyingQuestion + Answer (adaptive questioning history + confidence)

Roadmap + RoadmapStep (sequence, prerequisites, estimated_hours, mastery_check)

Resource + ResourceLink (provider, url, duration, difficulty, language, tags, quality signals)

Expose the whole domain through Django REST Framework endpoints (profiles, roadmaps, resources, progress) using ViewSets + routers to keep URL wiring simple.
​

Add auth + permissions:

Session auth for web, token/JWT for API consumers

Object-level permissions so users only access their own profiles/roadmaps

AI pipeline (adaptive Q → roadmap → resources)
Implement an “AI Orchestrator” service layer (plain Python module inside Django) with these steps:

Profile normalization: validate onboarding answers, map to canonical enums/taxonomy.

Uncertainty scoring: decide if 0–3 follow-up questions are needed (hard cap).

Roadmap planning: generate steps from a prerequisite graph + constraints (deadline, hours/week).

Resource retrieval/ranking: search curated catalog + external sources, rank by fit/quality, attach to steps.

Validation: enforce prerequisite ordering, time-budget totals, and “no empty step” constraints.

Run long AI calls asynchronously with Celery (Django app enqueues tasks; workers execute them via a broker such as Redis).
​

Optional but highly useful: add Django Channels so the UI can stream job status/progress over WebSockets; Channels uses an ASGI routing configuration similar to Django URLconf.
​

JSON roadmap export (machine-readable contract)
Define a versioned JSON schema (even if informal at first) and implement:

Roadmap.to_json() serializer (deterministic, no LLM text where it can break consumers)

“Export” endpoint: POST /api/roadmaps/{id}/export → produces a JSON file and returns a download URL

Store exports with metadata: schema_version, generated_at, model_versions (LLM + embeddings), and input_profile_hash for reproducibility.

Frontend (Django templates, modern UX)
Build server-rendered UI with Django templates + HTMX (or similar) for “app-like” interactions without a SPA:

Onboarding wizard (1 question/screen, progress indicator, back/skip)

Roadmap view as a path: steps as nodes, locked/active/completed states, “Start next step” CTA

Step detail drawer/panel: objectives, resources, mastery check, notes

Add an API-powered “Regenerate roadmap” flow that preserves user edits (pin steps/resources, then regenerate the rest).

Implement accessibility + polish: keyboard navigation, focus states, clear loading/progress feedback (especially while Celery jobs run), and mobile-first layout.


